// IPPT-3 standards evaluator (sit-ups, push-ups, 2.4km run)
// Synchronous, in-memory load via raw CSV imports (no fetch),
// to mirror the NAPFA-5 flow that uses JSON at build time.

// Prefer precompiled tables if present (generated by scripts/build-ippt3-tables.mjs)
// 1) Try a direct static import (fastest, most reliable in Vite)
// 2) Fallback to Vite import.meta.glob eager import
import ippt3Tables from '../data/ippt3_tables.js'
let _precompiled = (ippt3Tables && typeof ippt3Tables === 'object') ? ippt3Tables : null
try {
  if (!_precompiled && import.meta && import.meta.glob) {
    const g1 = import.meta.glob('/src/data/ippt3_tables.js', { eager: true })
    const g2 = import.meta.glob('../data/ippt3_tables.js', { eager: true })
    const g = { ...g1, ...g2 }
    const k = Object.keys(g)[0]
    _precompiled = k ? (g[k]?.default || null) : null
  }
} catch {}

let cache = { situp: null, pushup: null, run_km: null, tables: null }

function parseCsv(text) {
  const rows = []
  const lines = String(text || '').trim().split(/\r?\n/)
  if (!lines.length) return rows
  const headers = lines[0].split(',').map(s => s.trim())
  for (let i = 1; i < lines.length; i++) {
    const parts = lines[i].split(',')
    if (parts.length < headers.length) continue
    const obj = {}
    headers.forEach((h, idx) => (obj[h] = parts[idx]))
    // normalize numeric types commonly used
    if (obj.age_min != null) obj.age_min = Number(obj.age_min)
    if (obj.age_max != null) obj.age_max = Number(obj.age_max)
    if (obj.score != null) obj.score = Number(obj.score)
    if (obj.performance_reps != null) obj.performance_reps = Number(obj.performance_reps)
    rows.push(obj)
  }
  return rows
}

function timeToSeconds(mmss) {
  if (!mmss) return null
  const [m, s] = String(mmss).split(':').map((x) => Number(x))
  if (!Number.isFinite(m) || !Number.isFinite(s)) return null
  return m * 60 + s
}

function ensureLoadedSync() {
  if (cache.tables) return cache
  if (_precompiled) {
    cache = { situp: [], pushup: [], run_km: [], tables: _precompiled }
    return cache
  }
  // No precompiled tables found. For best performance, run: npm run build:ippt3:tables
  // Fallback to empty tables to avoid runtime crashes; will yield 0 points until generated.
  cache = { situp: [], pushup: [], run_km: [], tables: { situps:{male:{byAge:{},minAge:0,maxAge:0}, female:{byAge:{},minAge:0,maxAge:0}}, pushups:{male:{byAge:{},minAge:0,maxAge:0}, female:{byAge:{},minAge:0,maxAge:0}}, run:{male:{byAge:{},minAge:0,maxAge:0,maxSec:0}, female:{byAge:{},minAge:0,maxAge:0,maxSec:0}} } }
  return cache
}

function normSexKey(sex) { const s = String(sex||'').toLowerCase(); return s.startsWith('f') ? 'female' : 'male' }

function buildTables(src) {
  const genders = ['male','female']
  const tables = {
    situps: { male: { byAge: {}, minAge: Infinity, maxAge: -Infinity }, female: { byAge: {}, minAge: Infinity, maxAge: -Infinity } },
    pushups: { male: { byAge: {}, minAge: Infinity, maxAge: -Infinity }, female: { byAge: {}, minAge: Infinity, maxAge: -Infinity } },
    run: { male: { byAge: {}, minAge: Infinity, maxAge: -Infinity, maxSec: 0 }, female: { byAge: {}, minAge: Infinity, maxAge: -Infinity, maxSec: 0 } },
  }

  // Determine global per-gender age bounds and max seconds
  for (const sex of genders) {
    const sRows = src.situp.filter(r=> String(r.gender||'').toLowerCase()===sex)
    const pRows = src.pushup.filter(r=> String(r.gender||'').toLowerCase()===sex)
    const rRows = src.run_km.filter(r=> String(r.gender||'').toLowerCase()===sex)
    const minA = Math.min(...sRows.map(r=>r.age_min), ...pRows.map(r=>r.age_min), ...rRows.map(r=>r.age_min))
    const maxA = Math.max(...sRows.map(r=>r.age_max), ...pRows.map(r=>r.age_max), ...rRows.map(r=>r.age_max))
    tables.situps[sex].minAge = Math.min(tables.situps[sex].minAge, minA)
    tables.situps[sex].maxAge = Math.max(tables.situps[sex].maxAge, maxA)
    tables.pushups[sex].minAge = Math.min(tables.pushups[sex].minAge, minA)
    tables.pushups[sex].maxAge = Math.max(tables.pushups[sex].maxAge, maxA)
    tables.run[sex].minAge = Math.min(tables.run[sex].minAge, minA)
    tables.run[sex].maxAge = Math.max(tables.run[sex].maxAge, maxA)
    const maxSec = rRows.length ? Math.max(...rRows.map(r=> Number(r.max_s||0))) : 0
    tables.run[sex].maxSec = Math.max(tables.run[sex].maxSec, maxSec)
  }

  // Build per-age tables
  for (const sex of genders) {
    const sRows = src.situp.filter(r=> String(r.gender||'').toLowerCase()===sex)
    const pRows = src.pushup.filter(r=> String(r.gender||'').toLowerCase()===sex)
    const rRows = src.run_km.filter(r=> String(r.gender||'').toLowerCase()===sex)
    const minA = tables.situps[sex].minAge
    const maxA = tables.situps[sex].maxAge
    const maxSec = tables.run[sex].maxSec || 0
    for (let age=minA; age<=maxA; age++) {
      // situps
      const sArr = new Array(61).fill(0)
      const sBand = sRows.filter(r=> age>=r.age_min && age<=r.age_max)
      for (let reps=0; reps<=60; reps++) {
        let best=0
        for (const r of sBand) { if (reps >= Number(r.performance_reps||0)) best = Math.max(best, Number(r.score||0)) }
        sArr[reps]=best
      }
      tables.situps[sex].byAge[String(age)] = sArr

      // pushups
      const pArr = new Array(61).fill(0)
      const pBand = pRows.filter(r=> age>=r.age_min && age<=r.age_max)
      for (let reps=0; reps<=60; reps++) {
        let best=0
        for (const r of pBand) { if (reps >= Number(r.performance_reps||0)) best = Math.max(best, Number(r.score||0)) }
        pArr[reps]=best
      }
      tables.pushups[sex].byAge[String(age)] = pArr

      // run seconds table
      const rArr = new Array(maxSec+1).fill(0)
      const rBand = rRows.filter(r=> age>=r.age_min && age<=r.age_max)
      let bestScore = 0
      let minBandMin = Number.POSITIVE_INFINITY
      for (const rr of rBand) { bestScore = Math.max(bestScore, Number(rr.score||0)); minBandMin = Math.min(minBandMin, Number(rr.min_s||Infinity)) }
      for (const rr of rBand) {
        const mn = Number(rr.min_s||0); const mx = Number(rr.max_s||0); const sc = Number(rr.score||0)
        const lo = Math.max(0, mn); const hi = Math.min(maxSec, mx)
        for (let s=lo; s<=hi; s++) { if (sc > rArr[s]) rArr[s] = sc }
      }
      if (Number.isFinite(minBandMin)) {
        for (let s=0; s<Math.max(0, Math.min(minBandMin, rArr.length)); s++) rArr[s] = Math.max(rArr[s], bestScore)
      }
      tables.run[sex].byAge[String(age)] = rArr
    }
  }
  return tables
}

function findBand(rows, gender, age) {
  const g = String(gender||'').toLowerCase()
  return rows.filter(r => String(r.gender||'').toLowerCase() === g && age >= r.age_min && age <= r.age_max)
}

function pointsForReps(rows, reps) {
  if (reps == null || !Number.isFinite(reps)) return 0
  // choose highest score where performance_reps <= reps
  let best = 0
  for (const r of rows) {
    if (reps >= r.performance_reps) best = Math.max(best, r.score)
  }
  return best
}

function pointsForRun(rows, seconds) {
  if (seconds == null || !Number.isFinite(seconds)) return 0
  for (const r of rows) {
    if (seconds >= r.min_s && seconds <= r.max_s) return r.score
  }
  // faster than best range: take max score in cohort
  const max = rows.reduce((m,r)=> Math.max(m, r.score||0), 0)
  if (seconds < Math.min(...rows.map(r=>r.min_s))) return max
  return 0
}

export function evaluateIppt3({ sex, age }, measures) {
  const { tables } = ensureLoadedSync()
  const key = normSexKey(sex)
  const tS = tables.situps[key]; const tP = tables.pushups[key]; const tR = tables.run[key]
  const aSit = Math.max(tS.minAge, Math.min(tS.maxAge, Math.floor(Number(age)||0)))
  const aRun = Math.max(tR.minAge, Math.min(tR.maxAge, Math.floor(Number(age)||0)))
  const reps1 = Math.max(0, Math.min(60, Number(measures?.situps)||0))
  const reps2 = Math.max(0, Math.min(60, Number(measures?.pushups)||0))
  const sec = Math.max(0, Math.min(tR.maxSec||0, Number(measures?.run_seconds)||0))
  const sitPoints = (tS.byAge[String(aSit)]||[])[reps1] || 0
  const pushPoints = (tP.byAge[String(aSit)]||[])[reps2] || 0
  const runPoints = (tR.byAge[String(aRun)]||[])[sec] || 0

  const total = sitPoints + pushPoints + runPoints
  const award = awardForTotal(total, String(sex || ''))
  return {
    totalPoints: total,
    award,
    stations: {
      situps: { points: sitPoints },
      pushups: { points: pushPoints },
      run: { points: runPoints },
    }
  }
}

export function awardForTotal(total, sex) {
  const s = String(sex||'').toLowerCase()
  if (total >= 85) return 'Gold'
  if (total >= 75) return 'Silver'
  if (s === 'male') return (total >= 51 ? 'Pass' : 'No Award')
  return (total >= 61 ? 'Pass' : 'No Award')
}

export function cohortRowsIppt3({ sex, age }) {
  const { situp, pushup, run_km } = ensureLoadedSync()
  return { situps: findBand(situp, sex, age), pushups: findBand(pushup, sex, age), run: findBand(run_km, sex, age) }
}
